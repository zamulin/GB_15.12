Привет, GitHub и мир
Hello
Hello, Ivan!
# Инструкция по работе с Git

**_Git_** - это специальная программа, которая позволяет отслеживать любые изменения в файлах, хранить их версии и оперативно возвращаться в любое сохранённое состояние. Это система управления версиями с распределенной архитектурой.

Подход Git к хранению данных больше похож на набор снимков миниатюрной файловой системы. Каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта в Git, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок. Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён. Git представляет свои данные как, скажем, поток снимков.

У Git есть три основных состояния, в которых могут находиться ваши файлы: _изменён (modified), индексирован (staged) и зафиксирован (committed)_:

1. К **изменённым** относятся файлы, которые поменялись, но ещё не были зафиксированы.

2. **Индексированный** — это изменённый файл в его текущей версии, отмеченный для включения в следующий коммит.

3. **Зафиксированный** значит, что файл уже сохранён в вашей локальной базе.

**_Три основные секции проекта Git_**: _рабочая копия (working tree), область индексирования (staging area) и каталог Git (Git directory)_.
![3 секции Git](https://git-scm.com/book/en/v2/images/areas.png)

_Рабочая копия_ является снимком одной версии проекта. Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск, для того чтобы их можно было использовать или редактировать.

*Область индексирования* — это файл, обычно находящийся в каталоге Git, в нём содержится информация о том, что попадёт в следующий коммит. Её техническое название на языке Git — «индекс», но фраза «область индексирования» также работает.

*Каталог Git* — это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git и это та часть, которая копируется при клонировании репозитория с другого компьютера.

Базовый подход в работе с Git выглядит так:

- Изменяете файлы вашей рабочей копии.

- Выборочно добавляете в индекс только те изменения, которые должны попасть в следующий коммит, добавляя тем самым снимки только этих изменений в индекс.

- Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в ваш каталог Git.

## Работаем с Git

### Создание Git-репозитория

Обычно вы получаете репозиторий Git одним из двух способов:

- Вы можете взять локальный каталог, который в настоящее время не находится под версионным контролем, и превратить его в репозиторий Git, либо

- Вы можете клонировать существующий репозиторий Git из любого места.

В обоих случаях вы получите готовый к работе Git репозиторий на вашем компьютере.

## Команды Git

_*Все команды Git можно разделить на группы.*_ Рассмотрим их ниже:

1. Настройка и конфигурация
2. Клонирование и создание репозиториев
3. Основные команды
4. Ветвление и слияния
5. Совместная работа и обновление проектов
6. Осмотр и сравнение
7. Отладка
8. Внесение исправлений
9. Работа с помощью электронной почты
10. Внешние системы
11. Администрирование

### Настройка и конфигурация

- _git config_ - удобный способ для настройки параметров конфигурации в инсталляции Git. Обычно эту команду используют сразу после установки Git на новую машину разработчика.

* _git config core.editor_ - позволяет выбрать текстовый редактор в Git.

- _git help_ - служит для отображения встроенной документации Git о других командах.

### Клонирование и создание репозиториев

- _git init_ - инициализация локального репозитория. Как его создать можно почитать здесь <a id="title3"> Создание Git-репозитория </a>.

* _git clone <url-адрес репозитория>_ - клонирование внешнего репозитория на локальный ПК. На самом деле git clone работает как обёртка над некоторыми другими командами. Она создаёт новый каталог, переходит внутрь и выполняет git init для создания пустого репозитория, затем она добавляет новый удалённый репозиторий (git remote add) для указанного URL (по умолчанию он получит имя origin), выполняет git fetch для этого репозитория и, наконец, извлекает последний коммит в ваш рабочий каталог, используя git checkout.

### Основные команды

- _git status_ - дает возможность получить информацию о Git и его текущем статусе, показывает состояния файлов в рабочем каталоге и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

* _git add_ - добавить файл или файлы к следующему коммиту. Команда git add добавляет содержимое рабочего каталога в индекс (staging area) для последующего коммита. По умолчанию git commit использует лишь этот индекс, так что вы можете использовать git add для сборки слепка вашего следующего коммита.

- _git commit -m "коммит"_ - создание коммита. Команда git commit берёт все данные, добавленные в индекс с помощью git add, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

* _git reset_ - используется в основном для отмены изменений. Она изменяет указатель HEAD и, опционально, состояние индекса. Также эта команда может изменить файлы в рабочем каталоге при использовании параметра --hard, что может привести к потере наработок при неправильном использовании.

- _git rm_ - используется в Git для удаления файлов из индекса и рабочей копии. Она похожа на git add с тем лишь исключением, что она удаляет, а не добавляет файлы для следующего коммита.

- _git difftool_ - запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика git diff.

* _git diff_ - позволяет увидеть разницу между текущим файлом и коммит, используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей копией и индексом (собственно git diff), разница между индексом и последним коммитом (git diff --staged), или между любыми двумя коммитами (git diff master branchB).

* _git mv_ - это всего лишь удобный способ переместить файл, а затем выполнить git add для нового файла и git rm для старого.

* _git clean_ - используется для удаления мусора из рабочего каталога. Это могут быть результаты сборки проекта или файлы конфликтов слияний.

### Ветвление и слияния

- _git branch_ - посмотреть список веток в репозитории, умеет перечислять ваши ветки, создавать новые, удалять и переименовывать их.

- _git branch <название ветки>_ - создать новую ветку.

- _git branch -d <название ветки>_ – удалить ветку.

- _git checkout <название ветки>_ – для переключения веток и выгрузки их содержимого в рабочий каталог.

- _git merge_ - используется для слияния одной или нескольких веток в текущую. Затем она устанавливает указатель текущей ветки на результирующий коммит.

- _git mergetool_ - вызывает внешнюю программу слияний, в случае если у вас возникли проблемы слияния.

- _git log_ - вывод на экран истории всех коммитов с их хеш-кодами. По умолчанию, она показывает лишь историю текущей ветки, но может быть настроена на вывод истории других, даже нескольких сразу, веток. Также её можно использовать для просмотра различий между ветками на уровне коммитов.

- _git log --graph_ - просмотр истории в виде дерева.

- _git stash_ - используется для временного сохранения всех незафиксированных изменений с целью очистки рабочего каталога без необходимости фиксировать незавершённую работу в текущей ветке.

- _git tag_ - используется для задания постоянной метки на какой-либо момент в истории проекта. Обычно она используется для релизов.

### Совместная работа и обновление проектов

- _git fetch_ - связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

* _git pull_ - работает как комбинация команд git fetch и git merge, т. е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

- _git push_ - используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.

* _git remote_ - служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например «origin», так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и git remote поможет добавлять, изменять и удалять их.

- _git archive_ - используется для упаковки в архив указанных коммитов или всего репозитория.

* _git submodule_ - используется для управления вложенными репозиториями. Например, это могут быть библиотеки или другие, используемые не только в этом проекте ресурсы. У команды submodule есть несколько под-команд — add, update, sync и др. — для управления такими репозиториями.

### Осмотр и сравнение

- _git show_ - отображает объект в простом и человекопонятном виде. Обычно она используется для просмотра информации о метке или коммите.

* _git shortlog_ - служит для подведения итогов команды git log. Она принимает практически те же параметры, что и git log, но вместо простого листинга всех коммитов, они будут сгруппированы по автору.

- _git describe_ - принимает на вход что угодно, что можно трактовать как коммит (ветку, тег) и выводит более-менее человекочитаемую строку, которая не изменится в будущем для данного коммита. Это может быть использовано как более удобная, но по-прежнему уникальная, замена SHA-1.

### Отладка

- _git bisect_ - чрезвычайно полезная утилита для поиска коммита в котором впервые проявился баг или проблема с помощью автоматического бинарного поиска.

* _git blame_ - выводит перед каждой строкой файла SHA-1 коммита, последний раз менявшего эту строку и автора этого коммита. Это помогает в поисках человека, которому нужно задавать вопросы о проблемном куске кода.

- _git grep_ - спользуется для поиска любой строки или регулярного выражения в любом из файлов вашего проекта, даже в более ранних его версиях.

## Внесение исправлений

- _git cherry-pick_ - берёт изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке. Эта возможность полезна в ситуации, когда нужно забрать парочку коммитов из другой ветки, а не сливать ветку целиком со всеми внесёнными в неё изменениями.

* _git rebase_ - то «автоматизированный» cherry-pick. Он выполняет ту же работу, но для цепочки коммитов, тем самым как бы перенося ветку на новое место.

- _git revert_ - полная противоположность git cherry-pick. Она создаёт новый коммит, который вносит изменения, противоположные указанному коммиту, по существу отменяя его.

### Работа с помощью электронной почты

- _git apply_ - применяет патч, сформированный с помощью команды git diff или GNU diff. Она делает практически то же самое, что и команда patch.

* _git am_ - используется для применения патчей из входящих сообщений электронной почты, в частности, тех что используют формат mbox. Это используется для простого получения изменений через email и применения их к проекту.

- _git format-patch_ - используется для создания набора патчей в формате mbox которые можно использовать для отправки в список рассылки.

* _git send-email_ - используется для отсылки патчей, сформированных с использованием git format-patch, по электронной почте.

- _git request-pull_ - используется для генерации примерного текста сообщения для отсылки кому-либо. Если у вас есть ветка, хранящаяся на публичном сервере, и вы хотите чтобы кто-либо забрал эти изменения без возни с отсылкой патчей по электронной почте, вы можете выполнить эту команду и послать её вывод тому человеку.

### Внешние системы

- _git svn_ - используется для работы с сервером Subversion. Это означает, что вы можете использовать Git в качестве SVN клиента, забирать изменения и отправлять свои собственные на сервер Subversion.

* _git fast-import_ - Для других систем контроля версий, либо для импорта произвольно форматированных данных, вы можете использовать git fast-import, которая умеет преобразовывать данные в формат, понятный Git.

### Администрирование

- _git gc_ - запускает сборщик мусора в вашем репозитории, который удаляет ненужные файлы из хранилища объектов и эффективно упаковывает оставшиеся файлы.

* _git fsck_ - используется для проверки внутренней базы данных на предмет наличия ошибок и несоответствий.

- _git reflog_ - росматривает историю изменения голов веток на протяжении вашей работы для поиска коммитов, которые вы могли внезапно потерять, переписывая историю.

* _git filter-branch_ - используется для переписывания содержимого коммитов по заданному алгоритму, например, для полного удаления файла из истории или для вычленения истории лишь части файлов в проекте для вынесения в отдельный репозиторий.

## Как настроить совместную работу

1. Создать аккаунт на GitHub.com.
2. Создать локальный репозиторий.
3. “Подружить” ваш локальный и удалённый репозитории.
   GitHub при создании нового репозитория подскажет, как это можно сделать.
4. Отправить (push) ваш локальный репозиторий в удалённый (на GitHub), при этом, возможно, вам нужно будет авторизоваться на удалённом репозитории.
5. Провести изменения “с другого компьютера”.
6. Выкачать (pull) актуальное состояние из удалённого репозитория.

## Как сделать pull request

- Делаем (ответвление) репозитория fork.
- Делаем git clone СВОЕЙ версии репозитория.
- Создаем новую ветку и в НЕЕ вносим свои изменения.
- Фиксируем изменения (делаем коммиты).
- Отправляем свою версию в свой GitHub.
- На сайте GitHub нажимаем кнопку pull request.

**_ВАЖНО!_** Нужно быть аккуратнеев работе с ветками и вводом команд!!!

> Как говорил классик: "Тяжело в учении, легко в бою!"

Удачи в работе с Git!

![Взрыв мозга](AAAh.jpg)

Больше о Git [здесь](https://git-scm.com/)

[//]: # "Почему то не получается вставить эмодзи"
